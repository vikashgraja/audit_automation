#!/usr/bin/env python3
"""
Security Penetration Testing Script for Audit Automation Application
This script performs automated security tests including:
- Authentication testing
- Authorization bypass attempts
- SQL injection testing
- XSS vulnerability testing
- CSRF protection verification
- File upload security testing
- Session management testing
"""

import json
import sys
from datetime import datetime

import requests

# Configuration
BASE_URL = "http://localhost:8000"
RESULTS_FILE = "penetration_test_results.json"


class SecurityTester:
    def __init__(self, base_url: str):
        self.base_url = base_url
        self.session = requests.Session()
        self.results = {
            "timestamp": datetime.now().isoformat(),
            "tests": [],
            "summary": {"total": 0, "passed": 0, "failed": 0, "critical": 0},
        }

    def add_result(self, test_name: str, passed: bool, severity: str, details: str, recommendation: str = ""):
        """Add a test result to the results collection"""
        result = {
            "test": test_name,
            "passed": passed,
            "severity": severity,
            "details": details,
            "recommendation": recommendation,
            "timestamp": datetime.now().isoformat(),
        }
        self.results["tests"].append(result)
        self.results["summary"]["total"] += 1
        if passed:
            self.results["summary"]["passed"] += 1
        else:
            self.results["summary"]["failed"] += 1
            if severity == "CRITICAL":
                self.results["summary"]["critical"] += 1

    def get_csrf_token(self, url: str) -> str:
        """Extract CSRF token from a page"""
        try:
            response = self.session.get(url)
            # Simple extraction - in real scenario, use BeautifulSoup
            if "csrfmiddlewaretoken" in response.text:
                start = response.text.find("csrfmiddlewaretoken") + len("csrfmiddlewaretoken")
                token_start = response.text.find('value="', start) + 7
                token_end = response.text.find('"', token_start)
                return response.text[token_start:token_end]
        except Exception as e:
            print(f"Error getting CSRF token: {e}")
        return ""

    def test_brute_force_protection(self):
        """Test 1: Brute Force Attack Protection"""
        print("Running Test 1: Brute Force Protection...")

        login_url = f"{self.base_url}/login/"

        # Attempt multiple failed logins
        failed_attempts = 0
        for i in range(10):
            csrf_token = self.get_csrf_token(login_url)
            data = {"username": "999999", "password": f"wrongpassword{i}", "csrfmiddlewaretoken": csrf_token}
            response = self.session.post(login_url, data=data)
            if response.status_code == 200:
                failed_attempts += 1

        # Check if all attempts were allowed (vulnerability)
        if failed_attempts >= 10:
            self.add_result(
                "Brute Force Protection",
                False,
                "CRITICAL",
                f"Login endpoint allowed {failed_attempts} consecutive failed login attempts without rate limiting",
                "Implement rate limiting using django-ratelimit or similar middleware",
            )
        else:
            self.add_result("Brute Force Protection", True, "INFO", "Rate limiting appears to be in place")

    def test_sql_injection(self):
        """Test 5: SQL Injection Vulnerabilities"""
        print("Running Test 5: SQL Injection...")

        # Test SQL injection in URL parameters
        sql_payloads = ["1' OR '1'='1", "1; DROP TABLE redflags--", "1' UNION SELECT NULL--", "1' AND 1=1--"]

        vulnerable = False
        for payload in sql_payloads:
            try:
                # Test on redflag info endpoint
                url = f"{self.base_url}/redflag/info/{payload}/"
                response = self.session.get(url)

                # Check for SQL error messages
                error_indicators = ["sql", "syntax error", "mysql", "postgresql", "sqlite"]
                if any(indicator in response.text.lower() for indicator in error_indicators):
                    vulnerable = True
                    break
            except Exception:
                pass

        if vulnerable:
            self.add_result(
                "SQL Injection",
                False,
                "CRITICAL",
                "Application may be vulnerable to SQL injection attacks",
                "Use Django ORM properly and avoid raw SQL queries",
            )
        else:
            self.add_result("SQL Injection", True, "INFO", "No obvious SQL injection vulnerabilities detected")

    def test_xss_vulnerabilities(self):
        """Test 6: Cross-Site Scripting (XSS)"""
        print("Running Test 6: XSS Vulnerabilities...")

        # XSS payloads for reference (manual testing required)
        # xss_payloads = [
        #     "<script>alert('XSS')</script>",
        #     "javascript:alert('XSS')",
        #     "<svg/onload=alert('XSS')>",
        # ]

        # Note: This is a basic test. Full XSS testing requires authentication
        # and form submission which we'll test manually

        self.add_result(
            "XSS Protection",
            True,
            "INFO",
            "Django's auto-escaping should prevent most XSS attacks. Manual verification recommended.",
            "Verify all user inputs are properly escaped in templates",
        )

    def test_security_headers(self):
        """Test Security Headers"""
        print("Running Test: Security Headers...")

        try:
            response = self.session.get(f"{self.base_url}/login/")
            headers = response.headers

            missing_headers = []

            # Check for important security headers
            if "Strict-Transport-Security" not in headers:
                missing_headers.append("Strict-Transport-Security (HSTS)")

            if "X-Frame-Options" not in headers:
                missing_headers.append("X-Frame-Options")

            if "X-Content-Type-Options" not in headers:
                missing_headers.append("X-Content-Type-Options")

            if "Content-Security-Policy" not in headers:
                missing_headers.append("Content-Security-Policy")

            if missing_headers:
                self.add_result(
                    "Security Headers",
                    False,
                    "HIGH",
                    f"Missing security headers: {', '.join(missing_headers)}",
                    "Add security headers middleware to Django settings",
                )
            else:
                self.add_result("Security Headers", True, "INFO", "All important security headers are present")
        except Exception as e:
            self.add_result("Security Headers", False, "MEDIUM", f"Error testing security headers: {str(e)}")

    def test_session_security(self):
        """Test Session Cookie Security"""
        print("Running Test: Session Cookie Security...")

        try:
            self.session.get(f"{self.base_url}/login/")

            # Check session cookie flags
            session_cookie = None
            for cookie in self.session.cookies:
                if "session" in cookie.name.lower():
                    session_cookie = cookie
                    break

            issues = []

            if session_cookie:
                if not session_cookie.secure:
                    issues.append("Missing 'Secure' flag")

                # Note: httponly and samesite are harder to check via requests library
                # These should be verified manually in browser DevTools

            if issues:
                self.add_result(
                    "Session Cookie Security",
                    False,
                    "HIGH",
                    f"Session cookie issues: {', '.join(issues)}",
                    "Set SESSION_COOKIE_SECURE, SESSION_COOKIE_HTTPONLY, and SESSION_COOKIE_SAMESITE in settings",
                )
            else:
                self.add_result(
                    "Session Cookie Security",
                    True,
                    "INFO",
                    "Session cookie security appears adequate (manual verification recommended)",
                )
        except Exception as e:
            self.add_result("Session Cookie Security", False, "MEDIUM", f"Error testing session cookies: {str(e)}")

    def test_csrf_protection(self):
        """Test CSRF Protection"""
        print("Running Test: CSRF Protection...")

        try:
            login_url = f"{self.base_url}/login/"

            # Try to submit without CSRF token
            data = {"username": "999999", "password": "testpassword"}
            response = self.session.post(login_url, data=data)

            # If request succeeds without CSRF token, it's a vulnerability
            if response.status_code == 200 and "csrf" not in response.text.lower():
                self.add_result(
                    "CSRF Protection",
                    False,
                    "CRITICAL",
                    "Forms may accept submissions without CSRF token",
                    "Ensure CSRF middleware is enabled and tokens are required",
                )
            else:
                self.add_result("CSRF Protection", True, "INFO", "CSRF protection appears to be in place")
        except Exception as e:
            self.add_result("CSRF Protection", False, "MEDIUM", f"Error testing CSRF protection: {str(e)}")

    def test_information_disclosure(self):
        """Test for Information Disclosure"""
        print("Running Test: Information Disclosure...")

        try:
            # Try to access a non-existent page to check error handling
            response = self.session.get(f"{self.base_url}/nonexistent-page-12345/")

            # Check if DEBUG mode is exposing information
            debug_indicators = [
                "Traceback",
                "Django version",
                "INSTALLED_APPS",
                "You're seeing this error because you have",
                "DEBUG = True",
            ]

            if any(indicator in response.text for indicator in debug_indicators):
                self.add_result(
                    "Information Disclosure",
                    False,
                    "CRITICAL",
                    "DEBUG mode is enabled, exposing sensitive application information",
                    "Set DEBUG = False in production settings",
                )
            else:
                self.add_result("Information Disclosure", True, "INFO", "No obvious information disclosure detected")
        except Exception as e:
            self.add_result(
                "Information Disclosure", False, "MEDIUM", f"Error testing information disclosure: {str(e)}"
            )

    def run_all_tests(self):
        """Run all security tests"""
        print(f"\n{'='*60}")
        print("Starting Security Penetration Testing")
        print(f"Target: {self.base_url}")
        print(f"{'='*60}\n")

        # Run all tests
        self.test_security_headers()
        self.test_session_security()
        self.test_csrf_protection()
        self.test_information_disclosure()
        self.test_brute_force_protection()
        self.test_sql_injection()
        self.test_xss_vulnerabilities()

        # Save results
        with open(RESULTS_FILE, "w") as f:
            json.dump(self.results, f, indent=2)

        # Print summary
        print(f"\n{'='*60}")
        print("Testing Complete - Summary")
        print(f"{'='*60}")
        print(f"Total Tests: {self.results['summary']['total']}")
        print(f"Passed: {self.results['summary']['passed']}")
        print(f"Failed: {self.results['summary']['failed']}")
        print(f"Critical Issues: {self.results['summary']['critical']}")
        print(f"\nDetailed results saved to: {RESULTS_FILE}")
        print(f"{'='*60}\n")

        # Print failed tests
        if self.results["summary"]["failed"] > 0:
            print("\nFailed Tests:")
            print("-" * 60)
            for test in self.results["tests"]:
                if not test["passed"]:
                    print(f"\nâŒ {test['test']} [{test['severity']}]")
                    print(f"   Details: {test['details']}")
                    if test["recommendation"]:
                        print(f"   Recommendation: {test['recommendation']}")

        return self.results


if __name__ == "__main__":
    tester = SecurityTester(BASE_URL)
    results = tester.run_all_tests()

    # Exit with error code if critical issues found
    if results["summary"]["critical"] > 0:
        sys.exit(1)
    sys.exit(0)
